---
title: "字符串匹配"
date: 2021-02-24T15:47:09+08:00
draft: true
---

**BF**算法

暴力破解，从头开始，逐一在主串中比对模式串的每个字符，直到匹配成功。O(n*m)



**RK**算法（RabinKarp）

设计一个哈希算法，将字符串映射为一个整型。将模式串与子串的O(m)复杂度的比较转换为整型之间的比较。

哈希算法例子

将只有小写字母的字符串看成一个26进制数，然后转换为10进制数，这样子不同字符串得到的10进制数都是完全不同的。没有哈希冲突。同时每个子串的哈希值可以通过上一个相邻子串的哈希值快速算出。求出全部哈希值O(n）

但是这种方法可能会导致整型溢出。

例子2

将每个字母的ascii码相加，这样子会哈希冲突，但只要最后再加多一个完整子串判断即可



将主串的所有子串（n-m+1条），计算哈希值，将模式串计算哈希值，逐条对比，直到匹配成功O(n)



**golang**中的实现

当模式串短于63，并且主串短于64时，使用BF暴力搜索。

当模式串与主串都比较长时，使用RK算法。计算哈希值时的运行时溢出，会截取32位长度



**BM**算法



**Trie**树（字典树）



将字符串拆为一个个字符，每个字符为一个节点。从根节点到红色节点的遍历路径就是字符串本身。



树的构建

树的子节点用能包含字符集长度的数组表示，直接用child[ascii]

表示



树的查询

从第一个字符节点开始查询，直到完全匹配并且为红色节点



问题

每个节点都需要保存一个字符集长度的指纹数组，远远超过本身表达的一个字节。同时，如果这个节点的子节点比较少，数组会有很大浪费



应对策略

1. 可以用有序数组等数据结构替换这个子节点数组，或者用哈希表（会有一定空间浪费）
2. 对于只有一个子节点的节点，可以将它与子节点合并



应用场景

自动补全



敏感词过滤

*http://www.360doc.com/content/19/1115/10/33405611_873305276.shtml*

设字符串长度为n，将敏感词（个数为t）构建成一个trie树，设树高度为h，使用3指针法，查找到字符串所有敏感词复杂度为O(n*h)



若使用KMP精准匹配，查找所有单个敏感词复杂度为O(n+h)，查找到所有敏感词为O(t*(n+h))





**AC**自动机

ac自动机就是在trie树的基础上用了KMP算法的思想



**Sunday**算法

https://www.jianshu.com/p/2e6eb7386cd3





各种字符串匹配算法的使用场景与特点

**BF**	

暴力匹配，适合主串和模式串都不太长的场景（比如小于64），O(m*n)

**RK**

需要设计好哈希算法，降低哈希冲突的概率。O(n)

**KMP**

通过优化BF过程中字符串移动的长度，是最常用的单模式串匹配算法。O(n+m)

**Trie**树

多模式串匹配算法，构建一个前缀树。可以用来智能提示，也适合公共前缀较多的多模匹配场景。O(n*len),len是模式串平均长度

**AC**自动机

trie树在KMP算法下的优化版本，适合大量文本中多模式串的查找，O(n)