<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 无内鬼，写点东西</title>
    <link>https://shawling.github.io/posts/</link>
    <description>Recent content in Posts on 无内鬼，写点东西</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Tue, 02 Feb 2021 18:56:36 +0800</lastBuildDate><atom:link href="https://shawling.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>堆和堆的应用</title>
      <link>https://shawling.github.io/posts/heap/</link>
      <pubDate>Tue, 02 Feb 2021 18:56:36 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/heap/</guid>
      <description>是一个完全二叉树 堆中每个节点的值都大于等于（或小于等于）其左右子节点的值，分别对应大顶堆，小顶堆  因为完全二叉树适合用数组存储，所以堆通常放在一个数组中
堆的存储下标从1开始，方便计算（哨兵）。加入节点为i，左节点的地址为2i，右节点的位置为2i + 1
插入
由于性质1，堆的插入直接放在数组尾部。假设是大顶堆，如果插入值比父节点小，则直接计算地址交换，直到循环到根节点。
插入操作时间复杂度为O(logn)
这是从下往上的堆化方法
删除顶部元素
删除顶部节点后，拿最右侧节点填补，并拿取左右子节点的最大值进行交换，直到到达底部，这是从上往下的堆化方法
堆排序
建堆
使用从上往下的方法建堆，时间复杂度O(n)
排序
先建堆，然后逐个将顶部元素交换到最后，再堆化，可以得到一个最大值。循环整个数组，可以得到排好序的数组。时间复杂度O(nlogn)
堆排序时间复杂度跟快排差不多，但是
 在遍历有序数组时，每次选择时内存不连续，无法很好用到cpu缓存 建堆的第一步会把数组打乱，对于相对有序的数据，增加了逆序度，变相增加了操作次数。而快排的操作次数不会多于逆序度  所以快排在排序方面比堆排序更常用
堆的其他应用
堆在排序时，没有快排好用。但是如果需要一个插入，取出性能稳定的有序数据集时，堆比较好用。
堆的插入，删除数据并堆化复杂度为O(logn)。如果是快排排序号的数组，插入复杂度为O(n) （二分查找到位置后再逐个后移元素插入），删除同理。所以堆的动态更新性能比已排序数组好。
优先队列类型
优先队列一般用堆来实现，插入数据，删除数据都是O(logn)
合并有序小文件（比如日志文件）
建立一个堆，节点数量等于文件数量k，从多个小文件中读取第一个数据进堆并堆化。然后从堆顶取出一个数据，同时从它所属的文件中再读取一个数据放到堆顶并堆化，复杂度O(logk)。总的复杂度O(nlogk)，需要的额外内存空间O(k)
计时器
求TOPK类型
求动态数据集的中位数
先将数据从小到大排序，将前半部分n/2或n/2+1放入大顶堆，将后半部分放入小顶堆。这样子两个堆头（偶数）或者大顶堆堆头（奇数）就是好数据集的中位数。
在有新数据时，先与大顶堆比较，如果小于等于堆头，则放入大顶堆，如果节点数超过一半，则删除堆头并放入小顶堆，维持两个堆规范。
这样子求动态数据集的中位数复杂度为O(1)，插入新数据复杂度为O(logn)
求百分位数据同理</description>
    </item>
    
    <item>
      <title>前K大的数</title>
      <link>https://shawling.github.io/posts/top-k/</link>
      <pubDate>Fri, 29 Jan 2021 16:04:48 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/top-k/</guid>
      <description>TOP K
从数组中找到最大的K的数
思路一：
将整个数组排序，使用快排，O(n*logn)
思路二：
K后面的元素排序无意义，可以去掉这个步骤。使用冒泡排序，每次选择最大的一个数浮上去，重复K次后，可以得到结果，O(n*k)
思路三：
K个元素的排序也无意义，使用堆排序。取出前k个元素，建立一个小顶堆，O(k)，然后遍历剩下的n-k个元素，每个元素进堆为O(logk)，整个复杂度为O(k) + O((n-k)logk) = O(nlogk)
思路四：
分治法核心思路是把大问题分解为小问题，然后分开解决，最终解决大问题。
减治法是把大问题分解为小问题，然后只解决其中一个分支，也可以解决大问题。比如二分查找，每次只需要查找某一边，复杂度为O(logn).
这个问题也可以用减治法，称为随机选择。
利用快排的dopivot函数，将数组分为以i为中心的左大右小部分（分解问题），判断i与k的大小，可以知道k在i的哪一边。多次循环可以分出以k为中心的左大右小区域。循环次数与k大小无关，dopivot函数复杂度为O(n)，所以整个随机选择的复杂度为O(n)</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://shawling.github.io/posts/binary-tree/</link>
      <pubDate>Thu, 28 Jan 2021 11:37:27 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/binary-tree/</guid>
      <description>完全二叉树存储在数组中时，所有元素可以根据根元素的下标地址计算得出，所以完全二叉树适合用数组存储
堆就是一种完全二叉树，最常用的存储方式就是数组
二叉树的遍历
前中后序遍历指的是根节点的遍历顺序，左节点一定在右节点之前遍历
二叉查找树
利用二叉树的结构，并赋予左小右大的特性来储存数据
查找
递归思路查找
插入
递归思路找到父节点，并插入为叶子节点
删除
没有子节点：直接删除
有一个子节点：将父节点指向自己的指针指向子节点
有两个或子节点：找到右子树中最小的节点（必没有左节点），将这个节点删除并替换自己，这个节点的删除操作参见上两种方法
平衡二叉查找树
二叉查找树最好状态是一颗完全二叉树，最坏状态是一个链表
平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。
平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。
平衡二叉查找树与散列表
 散列表不支持按顺序区间遍历，需要额外数据结构（链表等）支持 散列表由于散列冲突的存在，装载因子不能太大，会浪费一定空间。同时散列冲突会导致散列表的性能不稳定 散列表在扩容时需要开辟新空间，转移新旧数据等，查找性能与空间使用都不太稳定  红黑树
红黑树是最常用的平衡二叉查找树。他通过几个定义，保证了自己的最大高度是2*logn
 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；  由来： 解决二叉查找树性能退化的问题
特性：近似平衡，最大高度是O(logn)
适用场景：动态插入删除查找的场景，同时对性能稳定性要求高
缺点：实现比较复杂，可以用跳表替代</description>
    </item>
    
    <item>
      <title>我来啦</title>
      <link>https://shawling.github.io/posts/my-first-post/</link>
      <pubDate>Fri, 15 Jan 2021 11:48:17 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/my-first-post/</guid>
      <description>😅</description>
    </item>
    
  </channel>
</rss>
